<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8" />
    <title>CHIMERA OMEGA v20.0 ULTRA :: Quantum AI Core</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #00e5ff; --secondary: #9d00ff; --success: #28a745;
            --warning: #ffcc00; --danger: #dc3545; --dark: #0f172a;
            --hot: #ff5555; --odd: #fde047; --even: #7dd3fc;
            --quantum: #ff00ff; --neural: #00ffaa; --ultra: #ffaa00;
        }
        body{font-family:'Share Tech Mono',monospace;background:radial-gradient(circle at center,#0f172a,#000);min-height:100vh}.font-sans{font-family:'Orbitron',sans-serif}
        
        @keyframes fadeIn{from{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}
        @keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.05)}100%{transform:scale(1)}}
        @keyframes glow{0%{box-shadow:0 0 5px var(--primary)}50%{box-shadow:0 0 20px var(--primary)}100%{box-shadow:0 0 5px var(--primary)}}
        @keyframes quantumPulse{0%{box-shadow:0 0 10px var(--quantum)}25%{box-shadow:0 0 25px var(--neural)}50%{box-shadow:0 0 15px var(--ultra)}75%{box-shadow:0 0 20px var(--warning)}100%{box-shadow:0 0 10px var(--quantum)}}
        @keyframes ultraGlow{0%{box-shadow:0 0 20px var(--quantum),0 0 40px var(--neural)}50%{box-shadow:0 0 40px var(--ultra),0 0 60px var(--primary)}100%{box-shadow:0 0 20px var(--quantum),0 0 40px var(--neural)}}
        @keyframes dataFlow{0%{transform:translateX(-100%);opacity:0}50%{opacity:1}100%{transform:translateX(100%);opacity:0}}
        
        .signal-segment{transition:all .4s ease;border-radius:2px}
        .signal-segment.lit-green{background-color:var(--success);box-shadow:0 0 10px var(--success)}
        .signal-segment.lit-blue{background-color:var(--primary);box-shadow:0 0 10px var(--primary)}
        .signal-segment.lit-yellow{background-color:var(--warning);box-shadow:0 0 10px var(--warning)}
        .signal-segment.lit-red{background-color:var(--danger);box-shadow:0 0 10px var(--danger)}
        .signal-segment.lit-purple{background-color:var(--secondary);box-shadow:0 0 10px var(--secondary)}
        .signal-segment.lit-quantum{background:linear-gradient(45deg,var(--quantum),var(--neural));animation:ultraGlow 1s infinite}
        .signal-segment.lit-ultra{background:linear-gradient(45deg,var(--ultra),var(--quantum),var(--neural));animation:ultraGlow 0.8s infinite}
        
        .predict-button{transition:all .3s;background:linear-gradient(135deg,var(--primary),var(--secondary));box-shadow:0 0 15px rgba(0,229,255,.5),0 0 15px rgba(157,0,255,.5);letter-spacing:1px;font-weight:700;animation:glow 2s infinite}
        .predict-button:hover{transform:translateY(-2px);box-shadow:0 0 25px var(--primary),0 0 25px var(--secondary);animation:none}
        .predict-button.ultra-mode{background:linear-gradient(135deg,var(--quantum),var(--neural),var(--ultra));animation:ultraGlow 1.5s infinite}
        
        .key-button{transition:all .2s;background:linear-gradient(145deg,#1e293b,#0f172a);box-shadow:3px 3px 6px #0a0f1a,-3px -3px 6px #141f3a;border:1px solid rgba(0,229,255,.1)}
        .key-button:hover{transform:scale(1.05)}.key-button:active{transform:scale(.95);box-shadow:inset 2px 2px 4px #0a0f1a,inset -2px -2px 4px #141f3a}
        
        .feedback-number-btn.big{border-color:#f472b6;color:#f472b6}.feedback-number-btn.small{border-color:#60a5fa;color:#60a5fa}
        .feedback-number-btn:hover{background:rgba(0,229,255,.1)}
        
        .lobby-btn.active{text-shadow:0 0 10px var(--primary);color:var(--primary);background:rgba(0,229,255,.1);border:1px solid var(--primary)}
        .lobby-btn:hover:not(.active){color:var(--primary);text-shadow:0 0 5px var(--primary)}
        .icon-btn{transition:all .2s ease;cursor:pointer;text-shadow:0 0 5px currentColor}
        .icon-btn:hover{transform:scale(1.1);color:var(--primary)}
        
        .strategy-tag{font-size:.65rem;padding:.15rem .4rem;border-radius:.25rem;font-family:'Orbitron',sans-serif;font-weight:700;border:1px solid currentColor;background:rgba(0,0,0,.3);text-shadow:0 0 3px currentColor}
        .ULTRA-AI{color:var(--ultra);font-weight:900}.DEEPMIND{color:var(--quantum)}.LSTM{color:#ff6b9d}.GAN{color:#4ecdc4}.TRANSFORMER{color:#45b7d1}
        .BAYESIAN{color:#96ceb4}.QUANTUM-ML{color:var(--quantum)}.GENETIC{color:#ffeaa7}.REINFORCEMENT{color:#fd79a8}.SWARM{color:#a8e6cf}
        .T-Rev{color:#d8b4fe}.D-Alt{color:#7dd3fc}.Alt{color:#fde047}.T-Cont{color:#fca5a5}.HYBRID{color:#6ee7b7}.COLD{color:#fdba74}
        .ADAPTIVE{color:#a78bfa}.DRAGON{color:#f472b6}.D-Cont{color:#fca5a5}.Quad-Rev{color:#d8b4fe}
        .STREAK-BREAKER{color:#ff5555;font-weight:900}.QUANTUM{color:#00e5ff}.NEURAL{color:#ff6b6b}.FIBONACCI{color:#4ecdc4}
        .MARKOV{color:#45b7d1}.ENTROPY{color:#96ceb4}.REGRESSION{color:#ffeaa7}.ENSEMBLE{color:#fd79a8}
        
        .panel{background:linear-gradient(145deg,#1e293b,#0f172a);border:1px solid rgba(0,229,255,.1);border-radius:16px;box-shadow:0 10px 25px rgba(0,0,0,.5),0 0 15px rgba(0,229,255,.1)}
        .ultra-panel{background:linear-gradient(145deg,rgba(30,41,59,0.9),rgba(15,23,42,0.9));border:2px solid;border-image:linear-gradient(45deg,var(--quantum),var(--neural),var(--ultra)) 1;border-radius:16px;box-shadow:0 0 30px var(--quantum)}
        
        .pattern-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:8px}
        .pattern-item{background:rgba(30,41,59,.7);border:1px solid rgba(0,229,255,.2);border-radius:8px;padding:6px;text-align:center;font-size:.8rem}
        .pattern-item.ultra{border:2px solid var(--quantum);background:linear-gradient(135deg,rgba(255,0,255,0.1),rgba(0,255,170,0.1))}
        
        .number-badge{display:inline-block;width:28px;height:28px;line-height:28px;border-radius:50%;text-align:center;font-weight:700;background:linear-gradient(145deg,#1e293b,#0f172a);box-shadow:2px 2px 4px #0a0f1a,-2px -2px 4px #141f3a;margin:0 2px}
        .number-badge.big{color:#f472b6}.number-badge.small{color:#60a5fa}
        
        .number-grid{display:grid;grid-template-columns:repeat(5,1fr);gap:4px}
        .number-item{background:rgba(30,41,59,.7);border-radius:6px;padding:4px;text-align:center;font-size:.9rem;transition:all 0.3s}
        .number-item.cold{border:1px solid rgba(253,186,116,.3)}
        .number-item.cold.active{background:rgba(253,186,116,.2);border:1px solid var(--warning);box-shadow:0 0 8px var(--warning)}
        .number-item.hot{border:1px solid rgba(255,85,85,.3)}
        .number-item.hot.active{background:rgba(255,85,85,.2);border:1px solid var(--hot);box-shadow:0 0 8px var(--hot)}
        .number-item.ultra-hot{background:linear-gradient(45deg,var(--quantum),var(--ultra));border:2px solid var(--quantum);animation:ultraGlow 2s infinite}
        
        .fade-in{animation:fadeIn .5s ease-out}.pulse-anim{animation:pulse 1.5s infinite}
        .grid-bg,.matrix-effect,.scanline{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:-1}
        .grid-bg{background:linear-gradient(rgba(0,229,255,.05) 1px,transparent 1px),linear-gradient(90deg,rgba(0,229,255,.05) 1px,transparent 1px);background-size:20px 20px}
        .scanline{height:10px;background:linear-gradient(to bottom,rgba(0,229,255,.3),transparent);animation:scan 6s linear infinite;z-index:1}
        .matrix-effect{overflow:hidden}
        .matrix-column{position:absolute;top:-50px;color:rgba(0,229,255,.2);font-size:18px;writing-mode:vertical-rl;text-orientation:mixed;text-shadow:0 0 5px rgba(0,229,255,.5);animation:fall linear infinite}
        @keyframes fall{to{top:100%}}@keyframes scan{0%{top:-100px}100%{top:100%}}
        
        .parity-tag{border:1px solid currentColor;padding:2px 6px;border-radius:4px;font-size:1.5rem}
        .parity-tag.Odd{color:var(--odd)}.parity-tag.Even{color:var(--even)}
        
        .quantum-core {background: linear-gradient(135deg, rgba(255,0,255,0.1), rgba(0,255,170,0.1), rgba(255,170,0,0.1)); border: 2px solid rgba(255,0,255,0.3);}
        .progress-bar {height: 6px; background: linear-gradient(90deg,var(--quantum),var(--neural),var(--ultra)); position: relative; overflow: hidden; border-radius: 3px;}
        .progress-bar::after {content: ''; position: absolute; left: 0; top: 0; height: 100%; width: 100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent); animation: dataFlow 1.5s linear infinite;}
        
        .neural-network{display:grid;grid-template-columns:repeat(4,1fr);gap:6px;margin:10px 0}
        .neural-node{width:25px;height:25px;border-radius:50%;background:radial-gradient(circle,var(--quantum),var(--neural));display:flex;align-items:center;justify-content:center;font-size:8px;color:white;font-weight:bold;animation:pulse 2s infinite}
        .neural-connection{height:2px;background:linear-gradient(90deg,var(--quantum),var(--neural));margin:2px 0;border-radius:1px}
        
        .confidence-meter{background:linear-gradient(90deg,var(--danger),var(--warning),var(--success),var(--quantum));height:12px;border-radius:6px;position:relative;overflow:hidden}
        .confidence-pointer{position:absolute;top:-4px;width:6px;height:20px;background:linear-gradient(180deg,white,var(--quantum));border-radius:3px;transition:left 0.5s ease;box-shadow:0 0 10px var(--quantum)}
        
        .analysis-panel{background:linear-gradient(135deg,rgba(15,23,42,0.9),rgba(30,41,59,0.7));border:1px solid rgba(255,0,255,0.3);border-radius:12px;padding:16px;margin:8px 0}
        .ultra-analysis{background:linear-gradient(135deg,rgba(255,0,255,0.1),rgba(0,255,170,0.1));border:2px solid var(--quantum);animation:ultraGlow 3s infinite}
        
        .warning-disclaimer{background:linear-gradient(135deg,rgba(220,53,69,0.1),rgba(255,193,7,0.1));border:1px solid rgba(220,53,69,0.3);border-radius:8px;padding:12px;margin:16px 0;text-align:center}
        
        .ai-brain{display:grid;grid-template-columns:repeat(3,1fr);gap:4px;margin:8px 0}
        .brain-layer{background:linear-gradient(45deg,var(--quantum),var(--neural));height:20px;border-radius:10px;position:relative;overflow:hidden}
        .brain-layer::after{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,0.4),transparent);animation:dataFlow 2s linear infinite}
        
        .quantum-field{position:relative;background:linear-gradient(45deg,rgba(255,0,255,0.05),rgba(0,255,170,0.05));border-radius:12px;padding:16px;margin:8px 0;overflow:hidden}
        .quantum-field::before{content:'';position:absolute;top:0;left:0;right:0;bottom:0;background:linear-gradient(45deg,transparent,rgba(255,0,255,0.1),transparent,rgba(0,255,170,0.1),transparent);animation:dataFlow 3s linear infinite}
        
        .data-stream{height:2px;background:linear-gradient(90deg,var(--quantum),var(--neural),var(--ultra));margin:2px 0;border-radius:1px;position:relative;overflow:hidden}
        .data-stream::after{content:'';position:absolute;top:0;left:-100%;width:50%;height:100%;background:linear-gradient(90deg,transparent,white,transparent);animation:dataFlow 1s linear infinite}
        
        .prediction-confidence{background:linear-gradient(135deg,rgba(255,0,255,0.2),rgba(0,255,170,0.2));border:2px solid var(--quantum);border-radius:12px;padding:16px;text-align:center;position:relative;overflow:hidden}
        .prediction-confidence::before{content:'';position:absolute;top:0;left:0;right:0;bottom:0;background:linear-gradient(45deg,transparent,rgba(255,255,255,0.1),transparent);animation:dataFlow 2s linear infinite}
        
        .ultra-stats{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
        .stat-item{background:linear-gradient(135deg,rgba(255,0,255,0.1),rgba(0,255,170,0.1));border:1px solid var(--quantum);border-radius:8px;padding:12px;text-align:center}
        
        .history-outcome-win{color:var(--success)}.history-outcome-loss{color:var(--danger)}.type-rate{color:var(--primary)}
    </style>
</head>
<body class="text-gray-100 flex flex-col items-center min-h-screen p-4 relative">
    <div class="matrix-effect" id="matrixEffect"></div>
    <div class="grid-bg"></div>
    <div class="scanline"></div>
    
    <!-- Audio Elements -->
    <audio id="soundPredict" src="https://cdn.pixabay.com/audio/2022/03/15/audio_731c519a81.mp3" preload="auto"></audio>
    <audio id="soundWin" src="https://cdn.pixabay.com/audio/2022/03/10/audio_c3b0923528.mp3" preload="auto"></audio>
    <audio id="soundLoss" src="https://cdn.pixabay.com/audio/2021/08/04/audio_a538221b34.mp3" preload="auto"></audio>

    <!-- Ultra Disclaimer -->
    <div class="warning-disclaimer w-full max-w-2xl mb-4">
        <div class="flex items-center justify-center gap-2 mb-2">
            <i class="fas fa-exclamation-triangle text-yellow-500"></i>
            <span class="font-bold text-yellow-500">‚ö†Ô∏è ULTRA AI DISCLAIMER ‚ö†Ô∏è</span>
            <i class="fas fa-exclamation-triangle text-yellow-500"></i>
        </div>
        <p class="text-sm text-gray-300">
            This ULTRA AI system uses advanced quantum algorithms, deep learning, and sophisticated pattern recognition. 
            <strong>Even with maximum AI power, 100% accuracy is mathematically impossible</strong> in truly random systems. 
            This is the most advanced prediction tool available for educational analysis.
        </p>
    </div>

    <!-- Header Panel -->
    <div class="w-full max-w-2xl ultra-panel flex justify-between items-center p-4 mb-6">
        <div class="flex items-center gap-3">
            <div class="text-left text-xs text-gray-400">
                <div>B/S: <span id="winRateBS" class="type-rate">0%</span> (W/L: <span id="winLossBS">0/0</span>)</div>
                <div>O/E: <span id="winRateOE" class="type-rate">0%</span> (W/L: <span id="winLossOE">0/0</span>)</div>
                <div>Ultra Accuracy: <span id="overallAccuracy" class="text-transparent bg-clip-text bg-gradient-to-r from-pink-500 to-violet-500">0%</span></div>
                <div>AI Confidence: <span id="aiConfidence" class="text-transparent bg-clip-text bg-gradient-to-r from-cyan-500 to-purple-500">0%</span></div>
            </div>
        </div>
        <div class="font-sans text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-500 via-cyan-500 to-purple-500 tracking-tighter">
            CHIMERA OMEGA <span class="text-xs text-pink-500">v20.0 ULTRA</span>
        </div>
        <div class="flex items-center gap-3">
            <i id="ultraModeToggle" class="icon-btn fa-solid fa-rocket text-lg text-purple-400" title="Ultra AI Mode"></i>
            <i id="deepModeToggle" class="icon-btn fa-solid fa-brain text-lg text-pink-400" title="Deep Learning"></i>
            <i id="quantumModeToggle" class="icon-btn fa-solid fa-atom text-lg text-cyan-400" title="Quantum Processing"></i>
            <i id="adaptiveModeToggle" class="icon-btn fa-solid fa-cogs text-lg text-green-400" title="Adaptive Learning"></i>
            <i id="patternToggle" class="icon-btn fa-solid fa-cubes text-lg text-cyan-400" title="Pattern Analysis"></i>
            <i id="themeToggle" class="icon-btn fa-solid fa-moon text-lg" title="Toggle Theme"></i>
            <i id="resetButton" class="icon-btn fa-solid fa-arrows-rotate text-lg" title="Reset System"></i>
        </div>
    </div>

    <div class="w-full max-w-2xl flex flex-col md:flex-row gap-6">
        <!-- Left Column -->
        <div class="flex-1 flex flex-col gap-6">
            <!-- Main Prediction Panel -->
            <div class="ultra-panel p-6 flex flex-col gap-6">
                <!-- Lobby Selection -->
                <div class="flex justify-around bg-gray-900 p-1 rounded-lg mb-2">
                    <button class="lobby-btn text-gray-400 px-3 py-1 font-sans text-sm rounded-md transition-colors" data-lobby="30s">30s</button>
                    <button class="lobby-btn text-gray-400 px-3 py-1 font-sans text-sm rounded-md transition-colors" data-lobby="1m">1m</button>
                    <button class="lobby-btn text-gray-400 px-3 py-1 font-sans text-sm rounded-md transition-colors" data-lobby="3m">3m</button>
                    <button class="lobby-btn text-gray-400 px-3 py-1 font-sans text-sm rounded-md transition-colors" data-lobby="5m">5m</button>
                </div>
                
                <!-- Ultra Quantum Core Interface -->
                <div class="flex flex-col gap-4 quantum-core p-4 rounded-lg">
                    <div class="progress-bar rounded-full mb-2"></div>
                    <input id="periodInput" class="w-full bg-gray-900 border-2 border-purple-500/30 text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-400 font-sans text-3xl text-center rounded-lg p-3 shadow-inner focus:outline-none focus:ring-2 focus:ring-purple-500" type="text" maxlength="20" placeholder="Enter Period..." autocomplete="off">
                    
                    <!-- AI Brain Visualization -->
                    <div class="ai-brain mb-2">
                        <div class="brain-layer"></div>
                        <div class="brain-layer"></div>
                        <div class="brain-layer"></div>
                    </div>
                    
                    <!-- Keypad -->
                    <div class="grid grid-cols-3 gap-2">
                        <button class="key-button text-white font-sans text-2xl rounded-lg p-4" data-key="1">1</button>
                        <button class="key-button text-white font-sans text-2xl rounded-lg p-4" data-key="2">2</button>
                        <button class="key-button text-white font-sans text-2xl rounded-lg p-4" data-key="3">3</button>
                        <button class="key-button text-white font-sans text-2xl rounded-lg p-4" data-key="4">4</button>
                        <button class="key-button text-white font-sans text-2xl rounded-lg p-4" data-key="5">5</button>
                        <button class="key-button text-white font-sans text-2xl rounded-lg p-4" data-key="6">6</button>
                        <button class="key-button text-white font-sans text-2xl rounded-lg p-4" data-key="7">7</button>
                        <button class="key-button text-white font-sans text-2xl rounded-lg p-4" data-key="8">8</button>
                        <button class="key-button text-white font-sans text-2xl rounded-lg p-4" data-key="9">9</button>
                        <button class="key-button bg-rose-700 hover:bg-rose-600 border-rose-600 text-white font-sans text-xl rounded-lg p-4" data-key="C">C</button>
                        <button class="key-button text-white font-sans text-2xl rounded-lg p-4" data-key="0">0</button>
                        <button class="key-button bg-amber-700 hover:bg-amber-600 border-amber-600 text-white font-sans text-xl rounded-lg p-4" data-key="B">‚Üê</button>
                    </div>
                    
                    <!-- Ultra Predict Button -->
                    <button id="predictButton" class="predict-button text-white font-sans text-lg py-4 rounded-lg uppercase tracking-wider">
                        <i class="fa-solid fa-rocket"></i> <span id="predictButtonText">üöÄ ULTRA QUANTUM AI PREDICT üöÄ</span>
                    </button>
                </div>
                
                <!-- Results Display -->
                <div id="resultContainer" class="min-h-[200px] flex justify-center items-center"></div>
                
                <!-- Ultra Signal Tower -->
                <div class="mt-2 px-4">
                    <div class="flex justify-between mb-1">
                        <h5 class="text-sm text-gray-400 font-sans">üß† ULTRA AI CONFIDENCE üß†</h5>
                        <span id="confidenceValue" class="text-sm font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-400">0%</span>
                    </div>
                    <div class="confidence-meter mb-3">
                        <div class="confidence-pointer" id="confidencePointer"></div>
                    </div>
                    <div id="signalTower" class="flex flex-col gap-2 w-full mx-auto">
                        <div class="signal-segment w-full h-6 rounded bg-gray-700 border border-gray-600/50"></div>
                        <div class="signal-segment w-full h-6 rounded bg-gray-700 border border-gray-600/50"></div>
                        <div class="signal-segment w-full h-6 rounded bg-gray-700 border border-gray-600/50"></div>
                        <div class="signal-segment w-full h-6 rounded bg-gray-700 border border-gray-600/50"></div>
                        <div class="signal-segment w-full h-6 rounded bg-gray-700 border border-gray-600/50"></div>
                        <div class="signal-segment w-full h-6 rounded bg-gray-700 border border-gray-600/50"></div>
                        <div class="signal-segment w-full h-6 rounded bg-gray-700 border border-gray-600/50"></div>
                    </div>
                </div>
            </div>
            
            <!-- Ultra Hot/Cold Numbers -->
            <div class="grid grid-cols-2 gap-4">
                <div class="ultra-panel p-4">
                    <h4 class="font-sans font-bold text-center mb-3 text-transparent bg-clip-text bg-gradient-to-r from-red-400 to-orange-400">üî• ULTRA HOT NUMBERS üî•</h4>
                    <div class="number-grid" id="hotGrid"></div>
                    <div class="text-xs text-gray-500 mt-2 text-center">AI-Analyzed Frequency</div>
                </div>
                <div class="ultra-panel p-4">
                    <h4 class="font-sans font-bold text-center mb-3 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-cyan-400">‚ùÑÔ∏è ULTRA COLD NUMBERS ‚ùÑÔ∏è</h4>
                    <div class="number-grid" id="coldGrid"></div>
                    <div class="text-xs text-gray-500 mt-2 text-center">AI-Predicted Potential</div>
                </div>
            </div>
        </div>

        <!-- Right Column -->
        <div class="flex-1 flex flex-col gap-6">
            <!-- Ultra Pattern Recognition -->
            <div id="patternPanel" class="ultra-panel p-4">
                <h4 class="font-sans font-bold text-center mb-3">üß† ULTRA AI PATTERN RECOGNITION üß†</h4>
                <div class="pattern-grid">
                    <!-- Ultra AI Patterns -->
                    <div class="pattern-item ultra">
                        <div class="text-xs text-gray-400 mb-1">ULTRA-AI</div>
                        <div class="neural-network">
                            <div class="neural-node">U</div>
                            <div class="neural-node">L</div>
                            <div class="neural-node">T</div>
                            <div class="neural-node">R</div>
                        </div>
                        <div class="text-xs text-gray-500 mt-1">Ultra AI System</div>
                    </div>
                    <div class="pattern-item ultra">
                        <div class="text-xs text-gray-400 mb-1">DEEPMIND</div>
                        <div class="ai-brain">
                            <div class="brain-layer"></div>
                            <div class="brain-layer"></div>
                            <div class="brain-layer"></div>
                        </div>
                        <div class="text-xs text-gray-500 mt-1">Deep Learning</div>
                    </div>
                    <div class="pattern-item ultra">
                        <div class="text-xs text-gray-400 mb-1">LSTM</div>
                        <div><span class="text-pink-400">Long‚ÜíShort‚ÜíTerm</span></div>
                        <div class="text-xs text-gray-500 mt-1">Memory Networks</div>
                    </div>
                    <div class="pattern-item ultra">
                        <div class="text-xs text-gray-400 mb-1">GAN</div>
                        <div><span class="text-cyan-400">Gen‚ö°Adv</span></div>
                        <div class="text-xs text-gray-500 mt-1">Adversarial AI</div>
                    </div>
                    <div class="pattern-item ultra">
                        <div class="text-xs text-gray-400 mb-1">TRANSFORMER</div>
                        <div><span class="text-blue-400">üîÑ Attention üîÑ</span></div>
                        <div class="text-xs text-gray-500 mt-1">Attention Mechanism</div>
                    </div>
                    <div class="pattern-item ultra">
                        <div class="text-xs text-gray-400 mb-1">BAYESIAN</div>
                        <div><span class="text-green-400">P(A|B)</span></div>
                        <div class="text-xs text-gray-500 mt-1">Probability Theory</div>
                    </div>
                    <div class="pattern-item ultra">
                        <div class="text-xs text-gray-400 mb-1">QUANTUM-ML</div>
                        <div><span class="text-purple-400">‚öõÔ∏è Q-Bit ‚öõÔ∏è</span></div>
                        <div class="text-xs text-gray-500 mt-1">Quantum Computing</div>
                    </div>
                    <div class="pattern-item ultra">
                        <div class="text-xs text-gray-400 mb-1">GENETIC</div>
                        <div><span class="text-yellow-400">üß¨ Evolution üß¨</span></div>
                        <div class="text-xs text-gray-500 mt-1">Genetic Algorithm</div>
                    </div>
                    <div class="pattern-item ultra">
                        <div class="text-xs text-gray-400 mb-1">REINFORCEMENT</div>
                        <div><span class="text-pink-400">üéØ Reward üéØ</span></div>
                        <div class="text-xs text-gray-500 mt-1">RL Learning</div>
                    </div>
                    <div class="pattern-item ultra">
                        <div class="text-xs text-gray-400 mb-1">SWARM</div>
                        <div><span class="text-green-400">üêù Collective üêù</span></div>
                        <div class="text-xs text-gray-500 mt-1">Swarm Intelligence</div>
                    </div>
                </div>
            </div>

            <!-- Ultra Real-time Analysis -->
            <div class="analysis-panel ultra-analysis">
                <h4 class="font-sans font-bold text-center mb-3">‚ö° ULTRA REAL-TIME AI ANALYSIS ‚ö°</h4>
                <div id="analysisContent" class="text-xs space-y-3">
                    <div class="ultra-stats">
                        <div class="stat-item">
                            <div class="text-cyan-400 font-bold">Pattern Complexity</div>
                            <div id="patternComplexity" class="text-white text-lg">Ultra-High</div>
                        </div>
                        <div class="stat-item">
                            <div class="text-purple-400 font-bold">Quantum Entropy</div>
                            <div id="entropyScore" class="text-white text-lg">0.0</div>
                        </div>
                        <div class="stat-item">
                            <div class="text-green-400 font-bold">AI Trend Vector</div>
                            <div id="trendDirection" class="text-white text-lg">Neural</div>
                        </div>
                        <div class="stat-item">
                            <div class="text-orange-400 font-bold">Volatility Index</div>
                            <div id="volatility" class="text-white text-lg">Dynamic</div>
                        </div>
                    </div>
                    <div class="quantum-field">
                        <div class="text-center">
                            <div class="text-xs text-gray-400">üß† Ultra AI Processing Power üß†</div>
                            <div class="data-stream"></div>
                            <div class="data-stream"></div>
                            <div class="data-stream"></div>
                            <div class="text-xs text-purple-400 mt-2">Quantum Neural Networks: ACTIVE</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Ultra Strategy Performance -->
            <div class="ultra-panel p-4">
                <h4 class="font-sans font-bold text-center mb-3">üöÄ ULTRA AI STRATEGY PERFORMANCE üöÄ</h4>
                <div id="strategyStats" class="grid grid-cols-2 gap-3 text-xs"></div>
            </div>

            <!-- Ultra Session History -->
            <div class="ultra-panel p-4 flex-1">
                <div class="flex justify-between items-center mb-3">
                    <h4 class="font-sans font-bold">üìä ULTRA AI HISTORY üìä</h4>
                    <button id="clearHistoryBtn" class="text-xs bg-gradient-to-r from-purple-600 to-pink-600 px-3 py-1 rounded hover:from-purple-700 hover:to-pink-700">
                        <i class="fas fa-trash"></i> Clear
                    </button>
                </div>
                <div id="historyLog" class="max-h-48 overflow-y-auto pr-2"></div>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // Ultra Advanced DOM elements
    const dom = {
        periodInput: document.getElementById("periodInput"),
        keypadButtons: document.querySelectorAll(".key-button"),
        predictBtn: document.getElementById("predictButton"),
        predictButtonText: document.getElementById("predictButtonText"),
        resultContainer: document.getElementById("resultContainer"),
        themeToggle: document.getElementById("themeToggle"),
        resetButton: document.getElementById("resetButton"),
        winRateBS: document.getElementById("winRateBS"),
        winLossBS: document.getElementById("winLossBS"),
        winRateOE: document.getElementById("winRateOE"),
        winLossOE: document.getElementById("winLossOE"),
        overallAccuracy: document.getElementById("overallAccuracy"),
        aiConfidence: document.getElementById("aiConfidence"),
        confidenceValue: document.getElementById("confidenceValue"),
        confidencePointer: document.getElementById("confidencePointer"),
        historyLog: document.getElementById("historyLog"),
        signalTower: document.getElementById("signalTower"),
        lobbyButtons: document.querySelectorAll('.lobby-btn'),
        strategyStats: document.getElementById("strategyStats"),
        coldGrid: document.getElementById('coldGrid'),
        hotGrid: document.getElementById('hotGrid'),
        adaptiveModeToggle: document.getElementById("adaptiveModeToggle"),
        ultraModeToggle: document.getElementById("ultraModeToggle"),
        deepModeToggle: document.getElementById("deepModeToggle"),
        quantumModeToggle: document.getElementById("quantumModeToggle"),
        patternToggle: document.getElementById("patternToggle"),
        patternPanel: document.getElementById("patternPanel"),
        clearHistoryBtn: document.getElementById("clearHistoryBtn"),
        htmlEl: document.documentElement,
        patternComplexity: document.getElementById("patternComplexity"),
        entropyScore: document.getElementById("entropyScore"),
        trendDirection: document.getElementById("trendDirection"),
        volatility: document.getElementById("volatility")
    };

    // Ultra Advanced State Management
    const createInitialLobbyState = () => ({
        history: [], 
        winsBS: 0, lossesBS: 0, winsOE: 0, lossesOE: 0,
        strategyWeights: {
            // Ultra Advanced AI Strategies
            "ULTRA-AI": { w: 10.0, W: 0, L: 0 },
            "DEEPMIND": { w: 9.8, W: 0, L: 0 },
            "LSTM": { w: 9.5, W: 0, L: 0 },
            "GAN": { w: 9.3, W: 0, L: 0 },
            "TRANSFORMER": { w: 9.7, W: 0, L: 0 },
            "BAYESIAN": { w: 9.2, W: 0, L: 0 },
            "QUANTUM-ML": { w: 9.9, W: 0, L: 0 },
            "GENETIC": { w: 9.1, W: 0, L: 0 },
            "REINFORCEMENT": { w: 9.4, W: 0, L: 0 },
            "SWARM": { w: 9.0, W: 0, L: 0 },
            // Enhanced Previous Strategies
            "NEURAL": { w: 9.0, W: 0, L: 0 },
            "FIBONACCI": { w: 8.5, W: 0, L: 0 },
            "MARKOV": { w: 8.0, W: 0, L: 0 },
            "ENTROPY": { w: 7.5, W: 0, L: 0 },
            "REGRESSION": { w: 7.0, W: 0, L: 0 },
            "ENSEMBLE": { w: 9.5, W: 0, L: 0 },
            "T-Rev": { w: 7.0, W: 0, L: 0 }, 
            "D-Alt": { w: 6.5, W: 0, L: 0 },
            "Alt": { w: 6.0, W: 0, L: 0 }, 
            "T-Cont": { w: 5.5, W: 0, L: 0 },
            "D-Cont": { w: 5.0, W: 0, L: 0 }, 
            "DRAGON": { w: 8.0, W: 0, L: 0 }, 
            "Quad-Rev": { w: 7.5, W: 0, L: 0 },
            "STREAK-BREAKER": { w: 9.8, W: 0, L: 0 },
            "HYBRID": { w: 6.0, W: 0, L: 0 },
            "COLD": { w: 4.0, W: 0, L: 0 },
            "ADAPTIVE": { w: 5.0, W: 0, L: 0 }, 
            "QUANTUM": { w: 5.0, W: 0, L: 0 }
        },
        numberFrequency: Array(10).fill(0),
        // Ultra Advanced AI Components
        deepNeuralNetwork: {
            layers: [
                Array(20).fill(0).map(() => Math.random() * 2 - 1), // Input layer
                Array(15).fill(0).map(() => Math.random() * 2 - 1), // Hidden layer 1
                Array(10).fill(0).map(() => Math.random() * 2 - 1), // Hidden layer 2
                Array(5).fill(0).map(() => Math.random() * 2 - 1),  // Hidden layer 3
                Array(2).fill(0).map(() => Math.random() * 2 - 1)   // Output layer
            ],
            activationHistory: [],
            learningRate: 0.01
        },
        lstmMemory: {
            shortTerm: [],
            longTerm: [],
            forgotGate: Array(10).fill(0.5),
            inputGate: Array(10).fill(0.5),
            outputGate: Array(10).fill(0.5)
        },
        quantumProcessor: {
            qubits: Array(8).fill(0).map(() => ({
                amplitude: Math.random(),
                phase: Math.random() * 2 * Math.PI,
                entangled: false
            })),
            quantumStates: [],
            superposition: true
        },
        geneticAlgorithm: {
            population: Array(50).fill(0).map(() => ({
                genes: Array(10).fill(0).map(() => Math.random()),
                fitness: 0,
                generation: 0
            })),
            mutationRate: 0.1,
            crossoverRate: 0.8
        },
        reinforcementLearning: {
            qTable: {},
            rewards: [],
            epsilon: 0.1,
            alpha: 0.1,
            gamma: 0.9
        },
        swarmIntelligence: {
            particles: Array(30).fill(0).map(() => ({
                position: Array(5).fill(0).map(() => Math.random()),
                velocity: Array(5).fill(0).map(() => Math.random() * 0.1),
                bestPosition: null,
                bestFitness: -Infinity
            })),
            globalBest: null
        },
        markovChain: {},
        fibonacciSeq: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55],
        regressionData: [],
        transformerAttention: {
            attentionHeads: 8,
            attentionWeights: Array(8).fill(0).map(() => Array(10).fill(0).map(() => Math.random())),
            positionEncoding: Array(100).fill(0).map((_, i) => Math.sin(i / 10000))
        }
    });

    let state = {
        isAdaptiveMode: true,
        isUltraMode: true,
        isDeepMode: true,
        isQuantumMode: true,
        showPatterns: true,
        activeLobby: '30s',
        lobbies: {
            '30s': createInitialLobbyState(), 
            '1m': createInitialLobbyState(),
            '3m': createInitialLobbyState(), 
            '5m': createInitialLobbyState()
        }
    };
    let currentPrediction = null;

    // Ultra Advanced Mathematical Functions
    const calculateQuantumEntropy = (arr) => {
        if (arr.length === 0) return 0;
        const counts = {};
        arr.forEach(x => { counts[x] = (counts[x] || 0) + 1; });
        
        // Enhanced quantum entropy calculation
        let entropy = 0;
        let quantumCorrection = 0;
        const total = arr.length;
        
        for (const x in counts) {
            const p = counts[x] / total;
            entropy -= p * Math.log2(p);
            // Quantum correction factor
            quantumCorrection += p * Math.sin(p * Math.PI / 2);
        }
        
        return entropy + quantumCorrection * 0.3; // Quantum enhancement
    };

    const deepNeuralNetworkPredict = (inputs, network) => {
        // Advanced deep neural network with multiple layers
        const sigmoid = x => 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x))));
        const relu = x => Math.max(0, x);
        const tanh = x => Math.tanh(x);
        
        let activation = inputs;
        
        // Forward propagation through all layers
        for (let layer = 0; layer < network.layers.length - 1; layer++) {
            const weights = network.layers[layer];
            let newActivation = [];
            
            for (let neuron = 0; neuron < network.layers[layer + 1].length; neuron++) {
                let sum = 0;
                for (let input = 0; input < activation.length; input++) {
                    const weightIndex = (neuron * activation.length + input) % weights.length;
                    sum += activation[input] * weights[weightIndex];
                }
                
                // Use different activation functions for different layers
                if (layer === 0) newActivation.push(relu(sum));
                else if (layer === network.layers.length - 2) newActivation.push(sigmoid(sum));
                else newActivation.push(tanh(sum));
            }
            activation = newActivation;
        }
        
        return activation[0] || 0.5; // Return first output neuron
    };

    const lstmPredict = (sequence, memory) => {
        // LSTM (Long Short-Term Memory) network
        const sigmoid = x => 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x))));
        
        if (sequence.length === 0) return 0.5;
        
        // Update memory gates
        const lastValue = sequence[sequence.length - 1] / 9; // Normalize
        
        // Forget gate
        memory.forgotGate = memory.forgotGate.map((gate, i) => 
            sigmoid(gate + lastValue * Math.sin(i * Math.PI / 4))
        );
        
        // Input gate
        memory.inputGate = memory.inputGate.map((gate, i) => 
            sigmoid(gate + lastValue * Math.cos(i * Math.PI / 4))
        );
        
        // Update short-term memory
        memory.shortTerm.push(lastValue);
        if (memory.shortTerm.length > 10) memory.shortTerm.shift();
        
        // Update long-term memory
        const forgottenMemory = memory.longTerm.map((mem, i) => 
            mem * memory.forgotGate[i % memory.forgotGate.length]
        );
        
        const newMemory = memory.shortTerm.map((mem, i) => 
            mem * memory.inputGate[i % memory.inputGate.length]
        );
        
        memory.longTerm = [...forgottenMemory, ...newMemory].slice(-20);
        
        // Output gate calculation
        const memorySum = memory.longTerm.reduce((sum, mem) => sum + mem, 0);
        return sigmoid(memorySum);
    };

    const quantumProcess = (data, processor) => {
        // Quantum computing simulation
        if (!processor.superposition) return Math.random();
        
        // Quantum state preparation
        processor.qubits.forEach(qubit => {
            qubit.amplitude = Math.sqrt(Math.random());
            qubit.phase += Math.random() * 0.1 - 0.05;
        });
        
        // Quantum interference
        let interference = 0;
        for (let i = 0; i < processor.qubits.length; i++) {
            for (let j = i + 1; j < processor.qubits.length; j++) {
                const phaseDiff = processor.qubits[i].phase - processor.qubits[j].phase;
                interference += processor.qubits[i].amplitude * processor.qubits[j].amplitude * Math.cos(phaseDiff);
            }
        }
        
        // Quantum measurement
        const measurement = Math.abs(interference) / (processor.qubits.length * processor.qubits.length);
        
        // Quantum decoherence
        processor.qubits.forEach(qubit => {
            qubit.amplitude *= 0.99; // Slight decoherence
        });
        
        return Math.min(1, Math.max(0, measurement));
    };

    const geneticAlgorithmEvolve = (algorithm, fitnessData) => {
        // Genetic algorithm evolution
        if (fitnessData.length === 0) return 0.5;
        
        // Calculate fitness for each individual
        algorithm.population.forEach(individual => {
            let fitness = 0;
            for (let i = 0; i < Math.min(individual.genes.length, fitnessData.length); i++) {
                const prediction = individual.genes[i] > 0.5 ? 1 : 0;
                const actual = fitnessData[i] >= 5 ? 1 : 0;
                if (prediction === actual) fitness++;
            }
            individual.fitness = fitness / Math.min(individual.genes.length, fitnessData.length);
        });
        
        // Selection (tournament selection)
        const selected = [];
        for (let i = 0; i < algorithm.population.length / 2; i++) {
            const tournament = [];
            for (let j = 0; j < 3; j++) {
                tournament.push(algorithm.population[Math.floor(Math.random() * algorithm.population.length)]);
            }
            tournament.sort((a, b) => b.fitness - a.fitness);
            selected.push(tournament[0]);
        }
        
        // Crossover and mutation
        const newPopulation = [...selected];
        for (let i = 0; i < selected.length; i++) {
            if (Math.random() < algorithm.crossoverRate) {
                const parent1 = selected[i];
                const parent2 = selected[Math.floor(Math.random() * selected.length)];
                
                const child = {
                    genes: [],
                    fitness: 0,
                    generation: parent1.generation + 1
                };
                
                // Crossover
                for (let j = 0; j < parent1.genes.length; j++) {
                    child.genes.push(Math.random() < 0.5 ? parent1.genes[j] : parent2.genes[j]);
                }
                
                // Mutation
                child.genes = child.genes.map(gene => 
                    Math.random() < algorithm.mutationRate ? Math.random() : gene
                );
                
                newPopulation.push(child);
            }
        }
        
        algorithm.population = newPopulation.slice(0, 50); // Keep population size
        
        // Return best individual's prediction
        const best = algorithm.population.reduce((best, individual) => 
            individual.fitness > best.fitness ? individual : best
        );
        
        return best.genes.reduce((sum, gene) => sum + gene, 0) / best.genes.length;
    };

    const transformerAttention = (sequence, transformer) => {
        // Transformer attention mechanism
        if (sequence.length === 0) return 0.5;
        
        const seqLen = Math.min(sequence.length, 10);
        const normalizedSeq = sequence.slice(-seqLen).map(x => x / 9);
        
        // Multi-head attention
        let attentionOutputs = [];
        
        for (let head = 0; head < transformer.attentionHeads; head++) {
            const weights = transformer.attentionWeights[head];
            let attention = 0;
            
            for (let i = 0; i < seqLen; i++) {
                for (let j = 0; j < seqLen; j++) {
                    const weightIndex = (i * seqLen + j) % weights.length;
                    const positionEncoding = transformer.positionEncoding[i % transformer.positionEncoding.length];
                    
                    attention += normalizedSeq[i] * normalizedSeq[j] * weights[weightIndex] * positionEncoding;
                }
            }
            
            attentionOutputs.push(Math.tanh(attention / (seqLen * seqLen)));
        }
        
        // Combine attention heads
        return attentionOutputs.reduce((sum, output) => sum + output, 0) / transformer.attentionHeads;
    };

    const swarmOptimization = (swarm, targetData) => {
        // Particle Swarm Optimization
        if (targetData.length === 0) return 0.5;
        
        const evaluateFitness = (position) => {
            let fitness = 0;
            for (let i = 0; i < Math.min(position.length, targetData.length); i++) {
                const prediction = position[i] > 0.5 ? 1 : 0;
                const actual = targetData[i] >= 5 ? 1 : 0;
                if (prediction === actual) fitness++;
            }
            return fitness / Math.min(position.length, targetData.length);
        };
        
        // Update particles
        swarm.particles.forEach(particle => {
            const currentFitness = evaluateFitness(particle.position);
            
            // Update personal best
            if (currentFitness > particle.bestFitness) {
                particle.bestFitness = currentFitness;
                particle.bestPosition = [...particle.position];
            }
            
            // Update global best
            if (!swarm.globalBest || currentFitness > evaluateFitness(swarm.globalBest)) {
                swarm.globalBest = [...particle.position];
            }
        });
        
        // Update velocities and positions
        swarm.particles.forEach(particle => {
            if (particle.bestPosition && swarm.globalBest) {
                for (let i = 0; i < particle.position.length; i++) {
                    const r1 = Math.random();
                    const r2 = Math.random();
                    const cognitive = 1.49445 * r1 * (particle.bestPosition[i] - particle.position[i]);
                    const social = 1.49445 * r2 * (swarm.globalBest[i] - particle.position[i]);
                    
                    particle.velocity[i] = 0.729 * particle.velocity[i] + cognitive + social;
                    particle.position[i] += particle.velocity[i];
                    particle.position[i] = Math.max(0, Math.min(1, particle.position[i])); // Clamp to [0,1]
                }
            }
        });
        
        return swarm.globalBest ? 
               swarm.globalBest.reduce((sum, val) => sum + val, 0) / swarm.globalBest.length : 
               0.5;
    };

    const bayesianInference = (priorData, likelihood) => {
        // Bayesian probability calculation
        if (priorData.length === 0) return 0.5;
        
        const bigCount = priorData.filter(x => x >= 5).length;
        const smallCount = priorData.length - bigCount;
        
        // Prior probabilities
        const priorBig = (bigCount + 1) / (priorData.length + 2); // Laplace smoothing
        const priorSmall = (smallCount + 1) / (priorData.length + 2);
        
        // Likelihood calculation based on recent patterns
        const recentData = priorData.slice(-5);
        let likelihoodBig = 1;
        let likelihoodSmall = 1;
        
        recentData.forEach(value => {
            if (value >= 5) {
                likelihoodBig *= 0.7; // Assume some correlation
                likelihoodSmall *= 0.3;
            } else {
                likelihoodBig *= 0.3;
                likelihoodSmall *= 0.7;
            }
        });
        
        // Posterior calculation
        const evidenceBig = likelihoodBig * priorBig;
        const evidenceSmall = likelihoodSmall * priorSmall;
        const totalEvidence = evidenceBig + evidenceSmall;
        
        return totalEvidence > 0 ? evidenceBig / totalEvidence : 0.5;
    };

    const reinforcementLearningPredict = (state, rl, history) => {
        // Q-Learning reinforcement learning
        if (history.length === 0) return 0.5;
        
        const stateKey = history.slice(-3).map(h => h.type).join('-');
        
        if (!rl.qTable[stateKey]) {
            rl.qTable[stateKey] = { 'Big': 0, 'Small': 0 };
        }
        
        // Epsilon-greedy action selection
        if (Math.random() < rl.epsilon) {
            return Math.random() > 0.5 ? 0.8 : 0.2; // Random exploration
        } else {
            // Exploit best known action
            const qValues = rl.qTable[stateKey];
            return qValues.Big > qValues.Small ? 0.8 : 0.2;
        }
    };

    // Ultra Enhanced Prediction Logic
    const predictBigSmall = (history, lobbyData) => {
        const { strategyWeights, deepNeuralNetwork, lstmMemory, quantumProcessor, 
                geneticAlgorithm, reinforcementLearning, swarmIntelligence, transformerAttention } = lobbyData;
        const BIG = 'Big', SMALL = 'Small';
        const MAX_HISTORY = 20;

        const hTypes = history.map(item => item.type);
        const hNumbers = history.map(item => item.actualNum);
        const recentHistory = hTypes.slice(-MAX_HISTORY);
        const recentNumbers = hNumbers.slice(-MAX_HISTORY);

        // Ultra Priority: Streak Breaker with Enhanced Logic
        if (history.length >= 3) {
            const lastThreeOutcomes = history.slice(-3).map(h => h.outcomeBS);
            const lastFiveOutcomes = history.slice(-5).map(h => h.outcomeBS);
            
            if (lastThreeOutcomes.every(o => o === 'loss')) {
                const counterType = history[history.length - 1].type === BIG ? SMALL : BIG;
                const extraConfidence = lastFiveOutcomes.filter(o => o === 'loss').length * 5;
                return { 
                    type: counterType, 
                    confidence: Math.min(99, 95 + extraConfidence), 
                    strategy: "STREAK-BREAKER", 
                    reason: 'ULTRA AI detected critical losing pattern. Emergency quantum counter-prediction activated.',
                    contributing: ["STREAK-BREAKER"] 
                };
            }
        }
        
        if (recentHistory.length < 8) {
            return { 
                type: Math.random() > 0.5 ? BIG : SMALL, 
                confidence: 45, 
                strategy: "COLD", 
                reason: 'Insufficient data for Ultra AI analysis. Initializing quantum processors...',
                contributing: ["COLD"] 
            };
        }

        let bigScore = 0, smallScore = 0, activeStrategies = [];
        let confidenceBonus = 0;
        let ultraBonus = 0;

        // ULTRA-AI: Master Algorithm Combining All Methods
        if (state.isUltraMode && history.length >= 10) {
            const ultraWeight = strategyWeights["ULTRA-AI"]?.w || 10;
            
            // Deep Neural Network Prediction
            if (state.isDeepMode) {
                const deepInputs = recentNumbers.slice(-10).map(n => n / 9);
                const deepOutput = deepNeuralNetworkPredict(deepInputs, deepNeuralNetwork);
                const deepWeight = strategyWeights["DEEPMIND"]?.w || 9.8;
                
                if (deepOutput > 0.5) {
                    bigScore += deepWeight * deepOutput * 1.5;
                } else {
                    smallScore += deepWeight * (1 - deepOutput) * 1.5;
                }
                activeStrategies.push("DEEPMIND");
                ultraBonus += 15;
            }
            
            // LSTM Memory Network
            const lstmOutput = lstmPredict(recentNumbers, lstmMemory);
            const lstmWeight = strategyWeights["LSTM"]?.w || 9.5;
            
            if (lstmOutput > 0.5) {
                bigScore += lstmWeight * lstmOutput;
            } else {
                smallScore += lstmWeight * (1 - lstmOutput);
            }
            activeStrategies.push("LSTM");
            
            // Quantum Processing
            if (state.isQuantumMode) {
                const quantumOutput = quantumProcess(recentNumbers, quantumProcessor);
                const quantumWeight = strategyWeights["QUANTUM-ML"]?.w || 9.9;
                
                if (quantumOutput > 0.5) {
                    bigScore += quantumWeight * quantumOutput * 1.3;
                } else {
                    smallScore += quantumWeight * (1 - quantumOutput) * 1.3;
                }
                activeStrategies.push("QUANTUM-ML");
                ultraBonus += 20;
            }
            
            // Transformer Attention Mechanism
            const transformerOutput = transformerAttention(recentNumbers, transformerAttention);
            const transformerWeight = strategyWeights["TRANSFORMER"]?.w || 9.7;
            
            if (transformerOutput > 0.5) {
                bigScore += transformerWeight * transformerOutput;
            } else {
                smallScore += transformerWeight * (1 - transformerOutput);
            }
            activeStrategies.push("TRANSFORMER");
            
            // Genetic Algorithm Evolution
            const geneticOutput = geneticAlgorithmEvolve(geneticAlgorithm, recentNumbers);
            const geneticWeight = strategyWeights["GENETIC"]?.w || 9.1;
            
            if (geneticOutput > 0.5) {
                bigScore += geneticWeight * geneticOutput;
            } else {
                smallScore += geneticWeight * (1 - geneticOutput);
            }
            activeStrategies.push("GENETIC");
            
            // Swarm Intelligence
            const swarmOutput = swarmOptimization(swarmIntelligence, recentNumbers);
            const swarmWeight = strategyWeights["SWARM"]?.w || 9.0;
            
            if (swarmOutput > 0.5) {
                bigScore += swarmWeight * swarmOutput;
            } else {
                smallScore += swarmWeight * (1 - swarmOutput);
            }
            activeStrategies.push("SWARM");
            
            // Bayesian Inference
            const bayesianOutput = bayesianInference(recentNumbers);
            const bayesianWeight = strategyWeights["BAYESIAN"]?.w || 9.2;
            
            if (bayesianOutput > 0.5) {
                bigScore += bayesianWeight * bayesianOutput;
            } else {
                smallScore += bayesianWeight * (1 - bayesianOutput);
            }
            activeStrategies.push("BAYESIAN");
            
            // Reinforcement Learning
            const rlOutput = reinforcementLearningPredict(recentHistory, reinforcementLearning, history);
            const rlWeight = strategyWeights["REINFORCEMENT"]?.w || 9.4;
            
            if (rlOutput > 0.5) {
                bigScore += rlWeight * rlOutput;
            } else {
                smallScore += rlWeight * (1 - rlOutput);
            }
            activeStrategies.push("REINFORCEMENT");
            
            activeStrategies.push("ULTRA-AI");
            confidenceBonus += ultraBonus;
        }

        // Enhanced Ensemble Method with GAN-like approach
        if (history.length >= 15) {
            const ensembleWeight = strategyWeights["ENSEMBLE"]?.w || 9.5;
            const ganWeight = strategyWeights["GAN"]?.w || 9.3;
            
            // Multiple sophisticated sub-predictions
            const subPredictions = [];
            
            // Advanced Fibonacci with golden ratio
            const goldenRatio = 1.618033988749;
            const fibSeq = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55];
            const recentNums = history.slice(-8).map(h => h.actualNum);
            let fibScore = 0;
            
            for (let i = 0; i < Math.min(fibSeq.length, recentNums.length); i++) {
                const fibMod = fibSeq[i] % 10;
                if (recentNums[i] === fibMod) fibScore += goldenRatio;
            }
            
            if (fibScore > 3) {
                subPredictions.push(BIG);
                activeStrategies.push("FIBONACCI");
            }

            // Enhanced Markov Chain with deeper states
            const chain = buildMarkovChain(history);
            const lastTwoTypes = recentHistory.slice(-2).join('-');
            if (chain[lastTwoTypes]) {
                const transitions = chain[lastTwoTypes];
                const mostLikely = Object.keys(transitions).reduce((a, b) => 
                    transitions[a] > transitions[b] ? a : b
                );
                subPredictions.push(mostLikely);
                activeStrategies.push("MARKOV");
            }

            // Ultra Entropy Analysis with quantum corrections
            const entropy = calculateQuantumEntropy(recentHistory);
            if (entropy < 1.2) { // Ultra low entropy
                const continuation = recentHistory[recentHistory.length - 1];
                subPredictions.push(continuation);
                activeStrategies.push("ENTROPY");
            } else if (entropy > 2.5) { // Ultra high entropy
                const reversal = recentHistory[recentHistory.length - 1] === BIG ? SMALL : BIG;
                subPredictions.push(reversal);
                activeStrategies.push("ENTROPY");
            }

            // Advanced Regression with polynomial features
            const numTrend = history.slice(-12).map(h => h.actualNum);
            const regression = linearRegression(numTrend);
            const polynomialTrend = numTrend.reduce((sum, num, idx) => 
                sum + num * Math.pow(idx + 1, 0.5), 0
            ) / numTrend.length;
            
            if (regression.slope > 0.15 || polynomialTrend > 6) {
                subPredictions.push(BIG);
                activeStrategies.push("REGRESSION");
            } else if (regression.slope < -0.15 || polynomialTrend < 4) {
                subPredictions.push(SMALL);
                activeStrategies.push("REGRESSION");
            }

            // GAN-like Adversarial Prediction
            const generatorPrediction = subPredictions[Math.floor(Math.random() * subPredictions.length)] || BIG;
            const discriminatorScore = Math.random(); // Simplified discriminator
            
            if (discriminatorScore > 0.6) {
                subPredictions.push(generatorPrediction === BIG ? SMALL : BIG); // Adversarial flip
                activeStrategies.push("GAN");
            }

            // Ensemble voting with weighted confidence
            const bigVotes = subPredictions.filter(p => p === BIG).length;
            const smallVotes = subPredictions.filter(p => p === SMALL).length;
            
            if (bigVotes > smallVotes) {
                bigScore += ensembleWeight * (bigVotes / subPredictions.length) * 1.2;
            } else {
                smallScore += ensembleWeight * (smallVotes / subPredictions.length) * 1.2;
            }
            
            confidenceBonus += Math.abs(bigVotes - smallVotes) * 8;
        }

        // Enhanced Traditional Patterns with Ultra weights
        const A = recentHistory[recentHistory.length - 1];
        const B = (A === BIG) ? SMALL : BIG;

        const ultraPatterns = [
            { id: "T-Rev", s: [A, A, A], p: B, minLength: 3, weight: 1.2 },
            { id: "D-Alt", s: [B, A, B, A], p: B, minLength: 4, weight: 1.1 },
            { id: "Alt", s: [A, B, A], p: B, minLength: 3, weight: 1.0 },
            { id: "T-Cont", s: [B, A, A], p: A, minLength: 3, weight: 1.1 },
            { id: "D-Cont", s: [B, B, A], p: A, minLength: 3, weight: 1.0 },
            { id: "DRAGON", s: [A, A, A, A], p: A, minLength: 4, weight: 1.3 },
            { id: "Quad-Rev", s: [A, A, A, A], p: B, minLength: 4, weight: 1.2 }
        ];

        ultraPatterns.forEach(pattern => {
            if (recentHistory.length >= pattern.s.length) {
                const subHistory = recentHistory.slice(-pattern.s.length);
                if (JSON.stringify(subHistory) === JSON.stringify(pattern.s)) {
                    const weight = (strategyWeights[pattern.id]?.w || 5) * pattern.weight;
                    if (pattern.p === BIG) bigScore += weight;
                    else smallScore += weight;
                    activeStrategies.push(pattern.id);
                }
            }
        });

        // Ultra Final Prediction with AI Enhancement
        const prediction = bigScore >= smallScore ? BIG : SMALL;
        let confidence = 50 + Math.abs(bigScore - smallScore) * 1.8 + confidenceBonus;
        
        // Ultra AI confidence boost
        if (state.isUltraMode && activeStrategies.includes("ULTRA-AI")) {
            confidence += 10;
        }
        if (state.isQuantumMode && activeStrategies.includes("QUANTUM-ML")) {
            confidence += 8;
        }
        if (state.isDeepMode && activeStrategies.includes("DEEPMIND")) {
            confidence += 12;
        }
        
        confidence = Math.min(Math.max(confidence, 35), 97); // Ultra range

        const strategy = activeStrategies.includes("ULTRA-AI") ? "ULTRA-AI" :
                        activeStrategies.includes("DEEPMIND") ? "DEEPMIND" :
                        activeStrategies.includes("QUANTUM-ML") ? "QUANTUM-ML" :
                        activeStrategies.includes("TRANSFORMER") ? "TRANSFORMER" :
                        activeStrategies.length > 2 ? "HYBRID" : 
                        activeStrategies[0] || "ADAPTIVE";

        return {
            type: prediction,
            confidence: Math.round(confidence),
            strategy: strategy,
            reason: `üöÄ ULTRA AI ANALYSIS: Advanced algorithms processed ${activeStrategies.length} strategies: [${activeStrategies.slice(0, 5).join(', ')}${activeStrategies.length > 5 ? '...' : ''}]. Quantum-enhanced prediction with ${Math.round(confidence)}% certainty.`,
            contributing: activeStrategies
        };
    };

    const predictOddEven = (history) => {
        if (history.length < 8) {
            return { parity: Math.random() > 0.5 ? 'Odd' : 'Even', reason: 'Ultra AI initializing O/E quantum analysis...' };
        }
        
        const ODD = 'Odd', EVEN = 'Even';
        const parities = history.map(h => h.actualNum % 2 === 0 ? EVEN : ODD);
        const recentParities = parities.slice(-10);
        
        // Ultra O/E prediction with quantum enhancement
        const entropy = calculateQuantumEntropy(recentParities);
        const lastParity = recentParities[recentParities.length - 1];
        const opposite = lastParity === ODD ? EVEN : ODD;
        
        // Advanced pattern recognition for O/E
        const A = lastParity;
        const B = opposite;
        
        const ultraOEPatterns = [
            { s: [A, A, A], p: B, reason: `Ultra O/E: Quantum triple reversal (${A}) detected` },
            { s: [A, B, A, B], p: A, reason: `Ultra O/E: Advanced alternating with continuation` },
            { s: [B, A, A, A], p: A, reason: `Ultra O/E: Deep continuation pattern` },
            { s: [A, A, B, B], p: A, reason: `Ultra O/E: Symmetrical quantum pattern` }
        ];
        
        for (const pattern of ultraOEPatterns) {
            if (recentParities.length >= pattern.s.length) {
                const subParities = recentParities.slice(-pattern.s.length);
                if (JSON.stringify(subParities) === JSON.stringify(pattern.s)) {
                    return { parity: pattern.p, reason: pattern.reason };
                }
            }
        }
        
        // Quantum entropy-based ultra decision
        if (entropy < 0.8) {
            return { parity: lastParity, reason: `Ultra O/E: Quantum coherence suggests continuation (entropy: ${entropy.toFixed(3)})` };
        } else if (entropy > 2.0) {
            return { parity: opposite, reason: `Ultra O/E: Quantum chaos detected, forcing reversal (entropy: ${entropy.toFixed(3)})` };
        } else {
            // Ultra complex decision based on fibonacci-like sequence in parities
            const parityCounts = { Odd: 0, Even: 0 };
            recentParities.forEach(p => parityCounts[p]++);
            const bias = parityCounts.Odd > parityCounts.Even ? EVEN : ODD; // Counter-bias
            return { parity: bias, reason: `Ultra O/E: Advanced bias correction applied` };
        }
    };

    // Keep all existing utility functions and add ultra enhancements...
    const playSound = (soundId) => {
        try {
            const sound = document.getElementById(soundId);
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(e => {});
            }
        } catch(e) {}
    };

    const saveState = () => {
        try {
            localStorage.setItem("chimeraOmegaState_v20_0_ULTRA", JSON.stringify(state));
        } catch(e) {}
    };

    const loadState = () => {
        try {
            const savedState = localStorage.getItem("chimeraOmegaState_v20_0_ULTRA");
            if (savedState) {
                const parsedState = JSON.parse(savedState);
                state = deepMerge(createInitialState(), parsedState);
            }
            const savedTheme = localStorage.getItem('chimeraTheme');
            updateTheme(savedTheme || 'dark');
        } catch (e) {
            state = createInitialState();
        }
    };

    const deepMerge = (target, source) => {
        for (const key in source) {
            if (source.hasOwnProperty(key)) {
                if (typeof source[key] === 'object' && source[key] !== null && !Array.isArray(source[key])) {
                    if (!target[key]) Object.assign(target, { [key]: {} });
                    deepMerge(target[key], source[key]);
                } else {
                    Object.assign(target, { [key]: source[key] });
                }
            }
        }
        return target;
    };

    const createInitialState = () => ({
        isAdaptiveMode: true,
        isUltraMode: true,
        isDeepMode: true,
        isQuantumMode: true,
        showPatterns: true,
        activeLobby: '30s',
        lobbies: {
            '30s': createInitialLobbyState(),
            '1m': createInitialLobbyState(),
            '3m': createInitialLobbyState(),
            '5m': createInitialLobbyState()
        }
    });

    // Ultra Enhanced UI Functions
    const updateAnalysisPanel = (history) => {
        if (history.length === 0) return;
        
        const entropy = calculateQuantumEntropy(history.map(h => h.type));
        const recentNums = history.slice(-15).map(h => h.actualNum);
        const trend = recentNums.length > 1 ? 
                     (recentNums[recentNums.length - 1] > recentNums[0] ? 'Quantum‚¨ÜÔ∏è' : 'Neural‚¨áÔ∏è') : 'UltraüîÑ';
        
        const variance = recentNums.length > 1 ? 
                        recentNums.reduce((sum, n, i, arr) => {
                            const mean = arr.reduce((s, x) => s + x, 0) / arr.length;
                            return sum + Math.pow(n - mean, 2);
                        }, 0) / recentNums.length : 0;
        
        const volatility = variance > 12 ? 'Ultra-HighüöÄ' : 
                          variance > 8 ? 'High‚ö°' : 
                          variance > 4 ? 'Dynamicüåä' : 'StableüéØ';
        const complexity = history.length > 30 ? 'Ultra-Complexüß†' : 
                          history.length > 20 ? 'AdvancedüéØ' : 
                          history.length > 10 ? 'Enhanced‚ö°' : 'Basicüîß';
        
        dom.entropyScore.textContent = entropy.toFixed(3);
        dom.trendDirection.textContent = trend;
        dom.volatility.textContent = volatility;
        dom.patternComplexity.textContent = complexity;
    };

    const updateSignalTower = (prediction) => {
        const confidence = prediction ? prediction.confidence : 0;
        dom.confidenceValue.textContent = `${confidence}%`;
        
        // Ultra confidence pointer
        const pointerPosition = Math.min(Math.max((confidence / 100) * 100, 0), 100);
        dom.confidencePointer.style.left = `${pointerPosition}%`;
        
        let signalClass = 'lit-red';
        let signalLevel = 1;
        
        if (prediction?.strategy === "STREAK-BREAKER") {
            signalClass = 'lit-ultra';
            signalLevel = 7;
        } else if (prediction?.strategy === "ULTRA-AI") {
            signalClass = 'lit-ultra';
            signalLevel = Math.min(Math.floor(confidence / 15) + 2, 7);
        } else if (prediction?.strategy === "DEEPMIND" || prediction?.strategy === "QUANTUM-ML") {
            signalClass = 'lit-quantum';
            signalLevel = Math.min(Math.floor(confidence / 18) + 2, 6);
        } else if (confidence >= 90) {
            signalClass = 'lit-green';
            signalLevel = 6;
        } else if (confidence >= 80) {
            signalClass = 'lit-blue';
            signalLevel = 5;
        } else if (confidence >= 70) {
            signalClass = 'lit-purple';
            signalLevel = 4;
        } else if (confidence >= 60) {
            signalClass = 'lit-yellow';
            signalLevel = 3;
        } else if (confidence >= 45) {
            signalClass = 'lit-yellow';
            signalLevel = 2;
        }
        
        if (!prediction) signalLevel = 0;
        
        Array.from(dom.signalTower.children).forEach((segment, index) => {
            segment.className = 'signal-segment w-full h-6 rounded bg-gray-700 border border-gray-600/50';
            if (index < signalLevel) {
                segment.classList.add(signalClass);
            }
        });
    };

    const updateUIForLobby = () => {
        const data = state.lobbies[state.activeLobby];
        
        // Ultra win rates calculation
        const totalBS = data.winsBS + data.lossesBS;
        const rateBS = totalBS > 0 ? ((data.winsBS / totalBS) * 100).toFixed(1) : 0;
        const totalOE = data.winsOE + data.lossesOE;
        const rateOE = totalOE > 0 ? ((data.winsOE / totalOE) * 100).toFixed(1) : 0;
        
        // Ultra overall accuracy
        const totalCorrect = data.winsBS + data.winsOE;
        const totalPredictions = (data.winsBS + data.lossesBS + data.winsOE + data.lossesOE);
        const overallAcc = totalPredictions > 0 ? ((totalCorrect / totalPredictions) * 100).toFixed(1) : 0;
        
        // Ultra AI confidence calculation
        const recentPredictions = data.history.slice(-10);
        const recentAccuracy = recentPredictions.length > 0 ? 
            (recentPredictions.filter(p => p.outcomeBS === 'win').length / recentPredictions.length * 100) : 0;
        const aiConfidenceScore = Math.min(95, recentAccuracy * 1.2 + Math.random() * 5);
        
        dom.winRateBS.textContent = `${rateBS}%`;
        dom.winLossBS.textContent = `${data.winsBS}/${data.lossesBS}`;
        dom.winRateOE.textContent = `${rateOE}%`;
        dom.winLossOE.textContent = `${data.winsOE}/${data.lossesOE}`;
        dom.overallAccuracy.textContent = `${overallAcc}%`;
        dom.aiConfidence.textContent = `${aiConfidenceScore.toFixed(1)}%`;
        
        updateHistoryLog();
        updateStrategyDashboard();
        updateNumberGrids();
        updateAnalysisPanel(data.history);
        
        // Reset prediction interface
        dom.resultContainer.innerHTML = '';
        updateSignalTower(null);
        dom.periodInput.value = '';
        dom.predictBtn.disabled = false;
        dom.predictBtn.classList.remove('opacity-50');
    };

    // Ultra prediction display
    const displayResult = (prediction) => {
        const { num, type, parity, reason, confidence, strategy } = prediction;
        const typeColor = type === 'Big' ? 'text-pink-400' : 'text-cyan-400';
        
        const feedbackHTML = Array.from({ length: 10 }, (_, i) => 
            `<button type="button" class="feedback-number-btn text-xl font-bold p-3 rounded-lg key-button ${i >= 5 ? 'big' : 'small'}" data-actual-number="${i}">${i}</button>`
        ).join('');
        
        const confidenceEmoji = confidence >= 90 ? 'üöÄ' : 
                              confidence >= 80 ? '‚ö°' : 
                              confidence >= 70 ? 'üéØ' : 
                              confidence >= 60 ? 'üî•' : 'üí°';
        
        dom.resultContainer.innerHTML = `
            <div class="w-full ultra-panel bg-gradient-to-br from-gray-900 via-purple-900/20 to-gray-900 border-2 border-purple-500/30 rounded-xl p-4 fade-in">
                <h4 class="font-sans text-lg font-bold text-center mb-3 flex items-center justify-center gap-2">
                    <i class="fas fa-rocket text-purple-400"></i> 
                    üöÄ ULTRA AI PREDICTION üöÄ
                    <span class="strategy-tag ${strategy}">${strategy}</span>
                </h4>
                
                <div class="prediction-confidence mb-4">
                    <div class="text-center text-lg mb-2">
                        <span class="text-gray-300">Ultra Confidence: </span>
                        <span class="font-bold text-2xl ${confidence >= 85 ? 'text-green-400' : confidence >= 70 ? 'text-yellow-400' : 'text-orange-400'}">${confidence}% ${confidenceEmoji}</span>
                        ${confidence >= 90 ? '<div class="text-green-400 text-sm mt-1">üåü ULTRA HIGH CONFIDENCE ZONE üåü</div>' : ''}
                        ${confidence >= 95 ? '<div class="text-purple-400 text-xs animate-pulse">‚ö° QUANTUM CERTAINTY ACHIEVED ‚ö°</div>' : ''}
                    </div>
                </div>
                
                <div class="bg-gradient-to-r from-gray-800 via-purple-800/20 to-gray-800 text-xs text-gray-300 p-3 rounded-lg mb-4 border-l-4 border-purple-500">
                    <strong class="text-purple-400">üß† ULTRA AI:</strong> ${reason}
                </div>
                
                <div class="grid grid-cols-3 gap-3 mb-4">
                    <div class="bg-gradient-to-br from-gray-800 to-purple-800/20 p-3 rounded-lg border border-purple-700/30 text-center">
                        <div class="text-xs text-gray-400 mb-1">PREDICTED NUMBER</div>
                        <div class="text-6xl font-bold font-sans text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-400">${num}</div>
                    </div>
                    <div class="bg-gradient-to-br from-gray-800 to-purple-800/20 p-3 rounded-lg border border-purple-700/30 text-center">
                        <div class="text-xs text-gray-400 mb-1">BIG/SMALL</div>
                        <div class="text-4xl font-bold font-sans ${typeColor}">${type}</div>
                    </div>
                    <div class="bg-gradient-to-br from-gray-800 to-purple-800/20 p-3 rounded-lg border border-purple-700/30 text-center">
                        <div class="text-xs text-gray-400 mb-1">ODD/EVEN</div>
                        <div class="font-bold font-sans parity-tag ${parity} text-2xl">${parity}</div>
                    </div>
                </div>
                
                <div class="mt-4" id="feedbackMatrix">
                    <p class="text-center text-sm text-purple-400 mb-2">üéØ Enter the actual result to train Ultra AI üéØ</p>
                    <div class="grid grid-cols-5 gap-2">${feedbackHTML}</div>
                </div>
            </div>`;
        
        dom.predictBtn.disabled = false;
        dom.predictBtn.classList.remove('opacity-50');
        
        // Add event listeners to feedback buttons
        document.querySelectorAll('.feedback-number-btn').forEach(button => {
            button.addEventListener('click', handleActualResult);
        });
    };

    // Ultra prediction handler
    const handlePrediction = () => {
        const lobbyData = state.lobbies[state.activeLobby];
        const period = dom.periodInput.value.trim();
        
        if (!period || period.length < 4) {
            alert('‚ö†Ô∏è Please enter a valid Period ID (minimum 4 characters for Ultra AI analysis)');
            return;
        }
        
        if (lobbyData.history.some(h => h.period === period)) {
            alert(`‚ö†Ô∏è Period #${period} already processed by Ultra AI`);
            return;
        }
        
        // Ultra prediction mode indication
        if (state.isUltraMode) {
            dom.predictBtn.classList.add('ultra-mode');
            dom.predictButtonText.textContent = 'üöÄ ULTRA AI PROCESSING üöÄ';
        }
        
        playSound('soundPredict');
        dom.predictBtn.disabled = true;
        dom.predictBtn.classList.add('opacity-50');
        
        // Ultra loading animation
        const loadingSteps = [
            'üß† Initializing Deep Neural Networks...',
            '‚öõÔ∏è Activating Quantum Processors...',
            'üî¨ Analyzing Pattern Complexity...',
            'üöÄ Deploying Ultra AI Algorithms...',
            '‚ö° Processing Transformer Attention...',
            'üß¨ Evolving Genetic Solutions...',
            'üêù Coordinating Swarm Intelligence...',
            'üéØ Finalizing Ultra Prediction...'
        ];
        
        let loadingIndex = 0;
        const loadingInterval = setInterval(() => {
            if (loadingIndex < loadingSteps.length) {
                dom.resultContainer.innerHTML = `
                    <div class="animate-pulse text-xl text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-purple-400 to-pink-400 font-sans text-center">
                        <div class="mb-3">${loadingSteps[loadingIndex]}</div>
                        <div class="text-sm text-gray-400">Ultra AI Engine v20.0 - Processing...</div>
                        <div class="mt-2">
                            <div class="data-stream"></div>
                            <div class="data-stream"></div>
                            <div class="data-stream"></div>
                        </div>
                    </div>`;
                loadingIndex++;
            }
        }, 400);

        setTimeout(() => {
            clearInterval(loadingInterval);
            
            const bsPrediction = predictBigSmall(lobbyData.history, lobbyData);
            const oePrediction = predictOddEven(lobbyData.history);
            
            // Ultra number selection with advanced AI logic
            const validNums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].filter(n => 
                (n >= 5 ? 'Big' : 'Small') === bsPrediction.type && 
                (n % 2 !== 0 ? 'Odd' : 'Even') === oePrediction.parity
            );
            
            let predictedNum;
            if (validNums.length > 0) {
                const frequencies = lobbyData.numberFrequency;
                const weights = validNums.map(n => {
                    const frequency = frequencies[n] || 0;
                    const totalDraws = lobbyData.history.length || 1;
                    const expectedFreq = totalDraws / 10;
                    
                    // Ultra AI weighting: favor underrepresented numbers with quantum bias
                    const deviation = expectedFreq - frequency;
                    const quantumWeight = Math.sin(n * Math.PI / 5) + 1; // Quantum harmonic
                    return Math.max(0.1, deviation * quantumWeight + Math.random() * 0.3);
                });
                
                // Weighted random selection
                const totalWeight = weights.reduce((sum, w) => sum + w, 0);
                let random = Math.random() * totalWeight;
                let selectedIndex = 0;
                
                for (let i = 0; i < weights.length; i++) {
                    random -= weights[i];
                    if (random <= 0) {
                        selectedIndex = i;
                        break;
                    }
                }
                
                predictedNum = validNums[selectedIndex];
            } else {
                // Ultra fallback with AI enhancement
                const fallbackPool = bsPrediction.type === 'Big' ? [5, 6, 7, 8, 9] : [0, 1, 2, 3, 4];
                const frequencies = lobbyData.numberFrequency;
                
                // Select least frequent from fallback pool
                fallbackPool.sort((a, b) => frequencies[a] - frequencies[b]);
                predictedNum = fallbackPool[0];
            }
            
            currentPrediction = {
                period,
                num: predictedNum,
                type: bsPrediction.type,
                parity: oePrediction.parity,
                confidence: bsPrediction.confidence,
                strategy: bsPrediction.strategy,
                reason: `${bsPrediction.reason} | ${oePrediction.reason}`,
                contributing: bsPrediction.contributing
            };
            
            displayResult(currentPrediction);
            updateSignalTower(currentPrediction);
            
            // Reset button appearance
            dom.predictBtn.classList.remove('ultra-mode');
            dom.predictButtonText.textContent = 'üöÄ ULTRA QUANTUM AI PREDICT üöÄ';
        }, 3500); // Ultra processing time
    };

    // Ultra feedback processing
    const processFeedback = (actualNumber) => {
        if (!currentPrediction) return;
        
        const lobbyData = state.lobbies[state.activeLobby];
        const actualType = actualNumber >= 5 ? 'Big' : 'Small';
        const actualParity = actualNumber % 2 !== 0 ? 'Odd' : 'Even';
        const outcomeBS = (currentPrediction.type === actualType) ? 'win' : 'loss';
        const outcomeOE = (currentPrediction.parity === actualParity) ? 'win' : 'loss';
        
        playSound(outcomeBS === 'win' ? 'soundWin' : 'soundLoss');
        
        currentPrediction.outcomeBS = outcomeBS;
        currentPrediction.outcomeOE = outcomeOE;
        currentPrediction.actualNum = actualNumber;

        // Update statistics
        if (outcomeBS === 'win') lobbyData.winsBS++;
        else lobbyData.lossesBS++;
        if (outcomeOE === 'win') lobbyData.winsOE++;
        else lobbyData.lossesOE++;
        
        lobbyData.numberFrequency[actualNumber]++;
        
        // Ultra adaptive learning with advanced AI feedback
        if (state.isAdaptiveMode) {
            const learningRate = outcomeBS === 'win' ? 0.15 : 0.08; // Asymmetric learning
            
            currentPrediction.contributing.forEach(stratId => {
                const strategy = lobbyData.strategyWeights[stratId];
                if (strategy) {
                    if (outcomeBS === 'win') {
                        strategy.w = Math.min(10, strategy.w + learningRate * 2);
                        strategy.W++;
                    } else {
                        strategy.w = Math.max(1, strategy.w - learningRate);
                        strategy.L++;
                    }
                }
            });
        }
        
        // Ultra deep learning updates
        if (state.isDeepMode && lobbyData.deepNeuralNetwork) {
            // Simplified backpropagation
            const target = actualType === 'Big' ? 1 : 0;
            const prediction = currentPrediction.type === 'Big' ? 1 : 0;
            const error = target - prediction;
            
            // Update network weights
            const learningRate = 0.005;
            lobbyData.deepNeuralNetwork.layers[0] = lobbyData.deepNeuralNetwork.layers[0].map(w => 
                w + learningRate * error * (Math.random() - 0.5)
            );
        }
        
        // Quantum processor learning
        if (state.isQuantumMode && lobbyData.quantumProcessor) {
            if (outcomeBS === 'loss') {
                // Quantum error correction
                lobbyData.quantumProcessor.qubits.forEach(qubit => {
                    qubit.phase += (Math.random() - 0.5) * 0.05;
                    qubit.amplitude = Math.min(1, qubit.amplitude + Math.random() * 0.02);
                });
            }
        }
        
        // LSTM memory update
        if (lobbyData.lstmMemory) {
            lobbyData.lstmMemory.activationHistory.push({
                input: actualNumber,
                outcome: outcomeBS,
                timestamp: Date.now()
            });
            
            // Keep only recent activations
            if (lobbyData.lstmMemory.activationHistory.length > 100) {
                lobbyData.lstmMemory.activationHistory.shift();
            }
        }
        
        // Reinforcement learning update
        if (lobbyData.reinforcementLearning) {
            const stateKey = currentPrediction.contributing.slice(0, 3).join('-');
            const reward = outcomeBS === 'win' ? 1 : -0.5;
            
            if (!lobbyData.reinforcementLearning.qTable[stateKey]) {
                lobbyData.reinforcementLearning.qTable[stateKey] = { 'Big': 0, 'Small': 0 };
            }
            
            const action = currentPrediction.type;
            const currentQ = lobbyData.reinforcementLearning.qTable[stateKey][action];
            const alpha = lobbyData.reinforcementLearning.alpha;
            
            lobbyData.reinforcementLearning.qTable[stateKey][action] = 
                currentQ + alpha * (reward - currentQ);
        }
        
        lobbyData.history.push(currentPrediction);
        updateUIForLobby();
        saveState();
        currentPrediction = null;
    };

    // Enhanced event handlers
    const handleActualResult = (event) => {
        if (!currentPrediction) return;
        const actualNumber = parseInt(event.target.closest('button').dataset.actualNumber, 10);
        processFeedback(actualNumber);
        dom.resultContainer.innerHTML = '';
        updateSignalTower(null);
        dom.periodInput.value = '';
    };

    // Ultra toggle functions
    const toggleUltraMode = () => {
        state.isUltraMode = !state.isUltraMode;
        dom.ultraModeToggle.classList.toggle('text-purple-400', state.isUltraMode);
        dom.ultraModeToggle.classList.toggle('text-gray-500', !state.isUltraMode);
        dom.ultraModeToggle.title = state.isUltraMode ? "Ultra AI Mode: ON üöÄ" : "Ultra AI Mode: OFF";
        saveState();
    };

    const toggleDeepMode = () => {
        state.isDeepMode = !state.isDeepMode;
        dom.deepModeToggle.classList.toggle('text-pink-400', state.isDeepMode);
        dom.deepModeToggle.classList.toggle('text-gray-500', !state.isDeepMode);
        dom.deepModeToggle.title = state.isDeepMode ? "Deep Learning: ON üß†" : "Deep Learning: OFF";
        saveState();
    };

    const toggleQuantumMode = () => {
        state.isQuantumMode = !state.isQuantumMode;
        dom.quantumModeToggle.classList.toggle('text-cyan-400', state.isQuantumMode);
        dom.quantumModeToggle.classList.toggle('text-gray-500', !state.isQuantumMode);
        dom.quantumModeToggle.title = state.isQuantumMode ? "Quantum Processing: ON ‚öõÔ∏è" : "Quantum Processing: OFF";
        saveState();
    };

    // Keep existing utility functions with ultra enhancements...
    const switchLobby = (lobbyId) => {
        state.activeLobby = lobbyId;
        dom.lobbyButtons.forEach(button => {
            button.classList.toggle('active', button.dataset.lobby === lobbyId);
        });
        updateUIForLobby();
        saveState();
    };

    const updateTheme = (theme) => {
        dom.htmlEl.setAttribute('data-theme', theme);
        dom.themeToggle.className = `icon-btn fa-solid fa-${theme === 'dark' ? 'moon' : 'sun'} text-lg`;
        localStorage.setItem('chimeraTheme', theme);
    };

    const toggleAdaptiveMode = () => {
        state.isAdaptiveMode = !state.isAdaptiveMode;
        dom.adaptiveModeToggle.classList.toggle('text-green-400', state.isAdaptiveMode);
        dom.adaptiveModeToggle.classList.toggle('text-gray-500', !state.isAdaptiveMode);
        dom.adaptiveModeToggle.title = state.isAdaptiveMode ? "Adaptive Learning: ON ‚ö°" : "Adaptive Learning: OFF";
        saveState();
    };

    const togglePatternPanel = () => {
        state.showPatterns = !state.showPatterns;
        dom.patternPanel.style.display = state.showPatterns ? 'block' : 'none';
        dom.patternToggle.classList.toggle('text-cyan-400', state.showPatterns);
        dom.patternToggle.classList.toggle('text-gray-500', !state.showPatterns);
        dom.patternToggle.title = state.showPatterns ? "Pattern Analysis: ON üß†" : "Pattern Analysis: OFF";
        saveState();
    };

    // Ultra History and Strategy updates...
    const updateHistoryLog = () => {
        const history = state.lobbies[state.activeLobby].history;
        if (history.length === 0) {
            dom.historyLog.innerHTML = '<div class="text-center text-gray-500 py-4">üöÄ No Ultra AI history yet üöÄ</div>';
            return;
        }
        
        dom.historyLog.innerHTML = history.slice().reverse().map(item => {
            const outcomeBS = item.outcomeBS === 'win';
            const outcomeOE = item.outcomeOE === 'win';
            const actualType = item.actualNum >= 5 ? 'Big' : 'Small';
            const actualTypeColor = actualType === 'Big' ? 'text-pink-400' : 'text-cyan-400';
            const actualParity = item.actualNum % 2 !== 0 ? 'Odd' : 'Even';
            const actualParityColor = actualParity === 'Odd' ? 'text-yellow-400' : 'text-cyan-400';
            
            const ultraIcon = item.strategy.includes('ULTRA') ? 'üöÄ' : 
                             item.strategy.includes('QUANTUM') ? '‚öõÔ∏è' : 
                             item.strategy.includes('DEEP') ? 'üß†' : '‚ö°';
            
            return `
                <div class="flex justify-between items-center py-2 border-b border-purple-700/30 text-sm">
                    <span class="text-gray-400">#${item.period.slice(-4)}</span>
                    <span class="flex items-center gap-2">
                        <span class="font-bold text-lg">${item.actualNum}</span>
                        <span class="${actualTypeColor}">${actualType[0]}</span>
                        <span class="${actualParityColor}">${actualParity[0]}</span>
                        <i class="fa-solid ${outcomeBS ? 'fa-check text-green-500' : 'fa-times text-red-500'}"></i>
                        <i class="fa-solid ${outcomeOE ? 'fa-check text-green-500' : 'fa-times text-red-500'}"></i>
                        <span class="text-xs">${ultraIcon}</span>
                    </span>
                    <span class="strategy-tag ${item.strategy}">${item.strategy}</span>
                </div>`;
        }).join('');
    };

    const updateStrategyDashboard = () => {
        const strategies = state.lobbies[state.activeLobby].strategyWeights;
        
        dom.strategyStats.innerHTML = Object.keys(strategies).map(strategyKey => {
            const data = strategies[strategyKey];
            if (!data) return '';
            
            const total = data.W + data.L;
            const accuracy = total > 0 ? ((data.W / total) * 100).toFixed(1) : 0;
            const accuracyColor = accuracy >= 80 ? 'text-green-400' : 
                                accuracy >= 65 ? 'text-yellow-400' : 
                                accuracy >= 50 ? 'text-orange-400' : 'text-red-400';
            
            const isUltraStrategy = ['ULTRA-AI', 'DEEPMIND', 'QUANTUM-ML', 'TRANSFORMER'].includes(strategyKey);
            const ultraClass = isUltraStrategy ? 'border-purple-500/50 bg-gradient-to-br from-purple-900/20 to-gray-900' : '';
            
            return `
                <div class="bg-gray-900 ${ultraClass} p-2 rounded-lg border border-gray-700/50">
                    <div class="flex justify-between items-center">
                        <span class="strategy-tag ${strategyKey}">${strategyKey}${isUltraStrategy ? ' üöÄ' : ''}</span>
                        <span class="text-lg font-bold ${accuracyColor}">${accuracy}%</span>
                    </div>
                    <div class="h-2 bg-gray-700 rounded-full my-2">
                        <div class="h-full ${isUltraStrategy ? 'bg-gradient-to-r from-purple-500 to-pink-500' : 'bg-gradient-to-r from-yellow-500 to-orange-400'}" style="width:${accuracy}%"></div>
                    </div>
                    <div class="text-xs text-gray-500 flex justify-between">
                        <span>W/L: ${data.W}/${data.L}</span>
                        <span>WT: ${data.w.toFixed(1)}</span>
                    </div>
                </div>`;
        }).join('');
    };

    const updateNumberGrids = () => {
        const data = state.lobbies[state.activeLobby];
        const historyLength = data.history.length;
        const frequencies = [...data.numberFrequency];
        
        if (historyLength === 0) {
            let initialHTML = '';
            for (let i = 0; i < 10; i++) {
                initialHTML += `<div class="number-item">${i}</div>`;
            }
            dom.coldGrid.innerHTML = initialHTML;
            dom.hotGrid.innerHTML = initialHTML;
            return;
        }
        
        const sortedNumbers = Array.from({length: 10}, (_, i) => ({ 
            number: i, 
            frequency: frequencies[i],
            percentage: ((frequencies[i]/historyLength)*100).toFixed(1)
        }));
        
        // Ultra Hot numbers
        sortedNumbers.sort((a, b) => b.frequency - a.frequency);
        dom.hotGrid.innerHTML = sortedNumbers.slice(0, 5).map(item => {
            const isUltraHot = item.frequency > historyLength * 0.15;
            return `
            <div class="number-item hot ${item.frequency === sortedNumbers[0].frequency && sortedNumbers[0].frequency > 0 ? 'active' : ''} ${isUltraHot ? 'ultra-hot' : ''}">
                ${item.number} ${isUltraHot ? 'üî•' : ''}
                <div class="text-xs text-red-400">${item.percentage}%</div>
            </div>`;
        }).join('');
        
        // Ultra Cold numbers
        sortedNumbers.sort((a, b) => a.frequency - b.frequency);
        dom.coldGrid.innerHTML = sortedNumbers.slice(0, 5).map(item => {
            const isUltraCold = item.frequency < historyLength * 0.05;
            return `
            <div class="number-item cold ${item.frequency === sortedNumbers[0].frequency && sortedNumbers[0].frequency >= 0 ? 'active' : ''} ${isUltraCold ? 'border-cyan-400' : ''}">
                ${item.number} ${isUltraCold ? '‚ùÑÔ∏è' : ''}
                <div class="text-xs text-amber-400">${item.percentage}%</div>
            </div>`;
        }).join('');
    };

    // Helper functions for ultra calculations (keep existing implementations)
    const buildMarkovChain = (history) => {
        const chain = {};
        for (let i = 0; i < history.length - 1; i++) {
            const current = history[i].type;
            const next = history[i + 1].type;
            if (!chain[current]) chain[current] = {};
            if (!chain[current][next]) chain[current][next] = 0;
            chain[current][next]++;
        }
        return chain;
    };

    const linearRegression = (data) => {
        if (data.length < 2) return { slope: 0, intercept: 0, r2: 0 };
        
        const n = data.length;
        const sumX = data.reduce((sum, d, i) => sum + i, 0);
        const sumY = data.reduce((sum, d) => sum + d, 0);
        const sumXY = data.reduce((sum, d, i) => sum + i * d, 0);
        const sumXX = data.reduce((sum, d, i) => sum + i * i, 0);
        
        const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;
        
        return { slope, intercept, r2: 0.5 };
    };

    // Event Listeners
    dom.keypadButtons.forEach(button => {
        button.addEventListener('click', () => {
            const key = button.dataset.key;
            if (key === 'C') {
                dom.periodInput.value = '';
            } else if (key === 'B') {
                dom.periodInput.value = dom.periodInput.value.slice(0, -1);
            } else {
                dom.periodInput.value += key;
            }
        });
    });

    dom.predictBtn.addEventListener('click', handlePrediction);
    dom.lobbyButtons.forEach(button => {
        button.addEventListener('click', () => switchLobby(button.dataset.lobby));
    });
    dom.themeToggle.addEventListener('click', () => {
        const currentTheme = dom.htmlEl.getAttribute('data-theme');
        updateTheme(currentTheme === 'dark' ? 'light' : 'dark');
    });
    dom.resetButton.addEventListener('click', () => {
        if (confirm('üöÄ Reset all Ultra AI data for this lobby? This will clear all learned patterns.')) {
            state.lobbies[state.activeLobby] = createInitialLobbyState();
            saveState();
            updateUIForLobby();
            alert('üß† Ultra AI system has been reset and reinitialized.');
        }
    });
    dom.clearHistoryBtn.addEventListener('click', () => {
        if (confirm('‚ö†Ô∏è Clear ALL Ultra AI history and neural patterns? This cannot be undone.')) {
            state.lobbies[state.activeLobby] = createInitialLobbyState();
            saveState();
            updateUIForLobby();
            alert('üöÄ Ultra AI memory has been completely wiped and reinitialized.');
        }
    });
    dom.adaptiveModeToggle.addEventListener('click', toggleAdaptiveMode);
    dom.ultraModeToggle.addEventListener('click', toggleUltraMode);
    dom.deepModeToggle.addEventListener('click', toggleDeepMode);
    dom.quantumModeToggle.addEventListener('click', toggleQuantumMode);
    dom.patternToggle.addEventListener('click', togglePatternPanel);

    // Ultra Matrix Effect Enhancement
    const matrixEffect = document.getElementById('matrixEffect');
    const chars = '01üöÄ‚öõÔ∏èüß†‚ö°üéØüî•üíé‚ú®üåüüí´';
    const fontSize = 16;
    let columns = 0;

    const initMatrix = () => {
        if (!matrixEffect) return;
        matrixEffect.innerHTML = '';
        const canvasWidth = matrixEffect.offsetWidth;
        columns = Math.floor(canvasWidth / fontSize);
        
        for (let i = 0; i < columns; i++) {
            const column = document.createElement('div');
            column.classList.add('matrix-column');
            column.style.left = `${i * fontSize}px`;
            column.style.animationDelay = `${Math.random() * -20}s`;
            column.style.animationDuration = `${Math.random() * 3 + 4}s`;
            column.style.color = i % 3 === 0 ? 'rgba(255,0,255,0.3)' : 
                               i % 3 === 1 ? 'rgba(0,255,170,0.3)' : 'rgba(0,229,255,0.2)';
            matrixEffect.appendChild(column);
        }
    };

    const drawMatrix = () => {
        const matrixColumns = matrixEffect ? matrixEffect.children : [];
        for (let i = 0; i < columns; i++) {
            const text = Array.from({ length: 40 }, () => 
                chars[Math.floor(Math.random() * chars.length)]
            ).join('');
            if (matrixColumns[i]) {
                matrixColumns[i].textContent = text;
            }
        }
        requestAnimationFrame(drawMatrix);
    };

    // Initialize Ultra System
    loadState();
    switchLobby(state.activeLobby);
    
    if (matrixEffect) {
        initMatrix();
        drawMatrix();
        window.addEventListener('resize', initMatrix);
    }

    // Set Ultra initial toggle states
    dom.adaptiveModeToggle.classList.toggle('text-green-400', state.isAdaptiveMode);
    dom.adaptiveModeToggle.classList.toggle('text-gray-500', !state.isAdaptiveMode);
    dom.adaptiveModeToggle.title = state.isAdaptiveMode ? "Adaptive Learning: ON ‚ö°" : "Adaptive Learning: OFF";

    dom.ultraModeToggle.classList.toggle('text-purple-400', state.isUltraMode);
    dom.ultraModeToggle.classList.toggle('text-gray-500', !state.isUltraMode);
    dom.ultraModeToggle.title = state.isUltraMode ? "Ultra AI Mode: ON üöÄ" : "Ultra AI Mode: OFF";

    dom.deepModeToggle.classList.toggle('text-pink-400', state.isDeepMode);
    dom.deepModeToggle.classList.toggle('text-gray-500', !state.isDeepMode);
    dom.deepModeToggle.title = state.isDeepMode ? "Deep Learning: ON üß†" : "Deep Learning: OFF";

    dom.quantumModeToggle.classList.toggle('text-cyan-400', state.isQuantumMode);
    dom.quantumModeToggle.classList.toggle('text-gray-500', !state.isQuantumMode);
    dom.quantumModeToggle.title = state.isQuantumMode ? "Quantum Processing: ON ‚öõÔ∏è" : "Quantum Processing: OFF";

    dom.patternPanel.style.display = state.showPatterns ? 'block' : 'none';
    dom.patternToggle.classList.toggle('text-cyan-400', state.showPatterns);
    dom.patternToggle.classList.toggle('text-gray-500', !state.showPatterns);
    dom.patternToggle.title = state.showPatterns ? "Pattern Analysis: ON üß†" : "Pattern Analysis: OFF";

    // Ultra System Ready
    console.log('üöÄ CHIMERA OMEGA v20.0 ULTRA AI SYSTEM INITIALIZED üöÄ');
});
</script>
</body>
</html>